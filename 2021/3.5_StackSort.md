题目名称： 用一个栈实现另一个栈的排序

在线地址：[点击跳转OJ](https://www.nowcoder.com/practice/ff8cba64e7894c5582deafa54cca8ff2?tpId=101&tqId=33081&rp=1&ru=%2Fta%2Fprogrammer-code-interview-guide&qru=%2Fta%2Fprogrammer-code-interview-guide%2Fquestion-ranking&tab=answerKey)



## 方法一（java实现）

两个栈，一个stack保存输入的内容，一个stackSort用作排序。

排序的方法是：

1. 获取stack栈顶元素current，与stackSort中的元素进行比较
2. 如果current大于stackSort的栈顶元素，则将current放入stackSort中
3. 如果current小于stackSort的栈顶元素，将stackSort的栈顶元素出栈，放入stack，重复第2步，直到stackSort为空或current大于stackSort的栈顶元素为止。

```java
import java.util.Scanner;
import java.util.Stack;
public class Main{

	public static void main(String[] args){
	
		Scanner sc=new Scanner(System.in);
		int n=sc.nextInt();
		Stack<Integer> stack=new Stack<Integer>();
		for(int i=0;i<n;i++){
			stack.push(sc.nextInt());
		}
		sort(stack);
	}

	public static void sort(Stack<Integer> stack){
		Stack<Integer> stackSort=new Stack<Integer>();
		while(!stack.isEmpty()){
			int current=stack.pop();
			while(!stackSort.isEmpty()&&current<stackSort.peek()){
				stack.push(stackSort.pop());
			}
			stackSort.push(current);
		}
		
		while(!stackSort.isEmpty()){
			System.out.print(stackSort.pop()+" ");
			
		}
	}
}
```
## 方法二(C++实现)

两个栈两个变量，时间消耗131ms, 空间消耗504kb。

实现思路是，反复交替将一个栈的元素压入另一个栈，更新最大值的同时输出最大值，直到两个栈都为空。

```c++
#include  <bits/stdc++.h>

using namespace std;

int main() {
    int N, number;
    int max_data = -1000005, max_work = -1000005;   //max_data保存s_data中的最大值, max_work保存s_work的最大值
    stack<int> s_data, s_work;
    cin >> N;
    while (N--) {   //输入数据
        cin >> number;
        s_data.push(number);
        if(number > max_data) max_data = number;
    }
    while (!s_data.empty() || !s_work.empty()) {    //反复将一个栈的元素压入另一个栈，同时更新最大值
        while (!s_data.empty()) {
            if (s_data.top() == max_data) {
                cout<<max_data<<" ";
                max_data = -1000005;
            } else {
                if(s_data.top() > max_work) max_work = s_data.top();
                s_work.push(s_data.top());
            }
            s_data.pop();
        }
        while (!s_work.empty()) {
            if (s_work.top() == max_work) {
                cout<<max_work<<" ";
                max_work = -1000005;
            } else {
                if(s_work.top() > max_data) max_data = s_work.top();
                s_data.push(s_work.top());
            }
            s_work.pop();
        }
    }
    return 0;
}
```




